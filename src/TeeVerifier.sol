// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {V3Quote} from "automata-dcap-attestation/contracts/types/V3Structs.sol";
// import "@automata-network/on-chain-pccs";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
// import "src/shared/common/EssentialContract.sol";
// import "src/shared/common/LibStrings.sol";
// import "../automata-attestation/interfaces/IAttestation.sol";
// import "../based/ITaikoL1.sol";
// import "../based/TaikoData.sol";
// import "./LibPublicInput.sol";
// import "./IVerifier.sol";

/// @title TeeVerifier
/// @notice Registers public keys to verify state transition signatures by the off-chain TEE prover.
/// Uses Automata's on-chain Intel DCAP Quote Verifier to ensure keys were generated in a secure
/// enclave. Inspired by the MIT-licensed Taiko implementation. Supports both Intel SGX and TDX.
/// @dev To learn more, see:
/// - Original idea:
///   https://ethresear.ch/t/2fa-zk-rollups-using-sgx/14462
/// - Automata onchain verifier:
///   https://github.com/automata-network/automata-dcap-attestation
/// - Taiko SGX verifier:
///   https://github.com/taikoxyz/taiko-mono/blob/de92b28c03b747845a8a1aa26991307d1ed47fd0/packages/protocol/contracts/layer1/verifiers/SgxVerifier.sol
/// @custom:security-contact security@matterlabs.dev
contract TeeVerifier {
    /// @dev Information about the validity of key pairs (instances) attested and registered in this
    /// contract.
    struct TeeInstance {
        uint64 validSince;
    }

    /// @notice The maximum expiry time for the key pair (TeeInstance). After this time, a new key pair
    /// must be regenerated off-chain, re-attested, and re-registered on-chain. The actual validity
    /// can be shorter if the attestation determines so (e.g., due to certificate expiration) or if
    /// the TEE prover decides to generate a new key pair earlier.
    uint64 public constant INSTANCE_EXPIRY = 60 days;

    /// @dev Collection of all public keys registered on-chain. The off-chain TEE prover uses the
    /// corresponding private keys to sign state transitions in the secure enclave. Each public key
    /// can be used to sign multiple transitions without rotating the keys for each verification
    /// (unlike in Taiko's implementation). Each key pair is generated by the off-chain TEE prover
    /// in a secure enclave and must be attested on-chain by verifying a remote attestation quote.
    /// Public keys are represented as Ethereum addresses to use the `ecrecover` precompile for
    /// signer address retrieval.
    mapping(address => TeeInstance) public instances;

    uint256[49] private __gap;

    /// @notice Emitted when a new instance is added or replaced.
    /// @param old_instance The address of the new instance.
    /// @param new_instance The address of the instance that was replaced. If it is the first instance,
    /// this value is the zero address.
    /// @param validSince The time since the instance is valid.
    /// @param validUntil The time until the instance is valid.
    event InstanceAdded(
        address indexed old_instance,
        address indexed new_instance,
        uint256 validSince,
        uint256 validUntil
    );

    error TEE_ALREADY_ATTESTED();
    error TEE_INVALID_INSTANCE();
    // error TEE_INVALID_ATTESTATION();
    // error TEE_INVALID_PROOF();
    // error TEE_RA_NOT_SUPPORTED();

    // /// @notice Initializes the contract.
    // /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.
    // /// @param _rollupAddressManager The address of the {AddressManager} contract.
    // function init(address _owner, address _rollupAddressManager) external initializer {
    //     __Essential_init(_owner, _rollupAddressManager);
    // }

    // /// @notice Deletes SGX instances from the registry.
    // /// @param _ids The ids array of SGX instances.
    // function deleteInstances(uint256[] calldata _ids)
    //     external
    //     onlyFromOwnerOrNamed(LibStrings.B_SGX_WATCHDOG)
    // {
    //     for (uint256 i; i < _ids.length; ++i) {
    //         uint256 idx = _ids[i];

    //         require(instances[idx].addr != address(0), TEE_INVALID_INSTANCE());

    //         emit InstanceDeleted(idx, instances[idx].addr);

    //         delete instances[idx];
    //     }
    // }

    function registerSgxInstance(V3Quote calldata attestation) external {
        this.registerSgxInstance(attestation, 0);
    }

    /// @notice Adds an SGX instance after verifying the attestation.
    /// @param attestation The parsed attestation quote.
    /// @param validity_delay_in_seconds Delay before an instance becomes valid.
    function registerSgxInstance(
        V3Quote calldata attestation,
        uint64 validity_delay_in_seconds
    ) external {
        // TODO verify attestation before registration
        // address automataDcapAttestation = resolve(
        //     LibStrings.B_AUTOMATA_DCAP_ATTESTATION,
        //     true
        // );
        // require(automataDcapAttestation != address(0), SGX_RA_NOT_SUPPORTED());
        // (bool verified, ) = IAttestation(automataDcapAttestation)
        //     .verifyParsedQuote(attestation);
        // require(verified, SGX_INVALID_ATTESTATION());
        address addr = address(
            bytes20(attestation.localEnclaveReport.reportData)
        );
        uint64 valid_since = uint64(block.timestamp) +
            validity_delay_in_seconds;
        _addInstance(addr, valid_since);
    }

    function _addInstance(address addr, uint64 validSince) private {
        require(addr != address(0), TEE_INVALID_INSTANCE());
        require(instances[addr].validSince == 0, TEE_ALREADY_ATTESTED());

        instances[addr] = TeeInstance(validSince);

        emit InstanceAdded(
            address(0),
            addr,
            validSince,
            validSince + INSTANCE_EXPIRY
        );
    }

    // /// @inheritdoc IVerifier
    // function verifyProof(
    //     Context calldata _ctx,
    //     TaikoData.Transition calldata _tran,
    //     TaikoData.TierProof calldata _proof
    // )
    //     external
    //     onlyFromNamedEither(LibStrings.B_TAIKO, LibStrings.B_TIER_TEE_ANY)
    // {
    //     // Do not run proof verification to contest an existing proof
    //     if (_ctx.isContesting) return;

    //     // Size is: 89 bytes
    //     // 4 bytes + 20 bytes + 65 bytes (signature) = 89
    //     require(_proof.data.length == 89, SGX_INVALID_PROOF());

    //     uint32 id = uint32(bytes4(_proof.data[:4]));
    //     address newInstance = address(bytes20(_proof.data[4:24]));

    //     address oldInstance = ECDSA.recover(
    //         LibPublicInput.hashPublicInputs(
    //             _tran, address(this), newInstance, _ctx.prover, _ctx.metaHash, taikoChainId()
    //         ),
    //         _proof.data[24:]
    //     );

    //     require(_isInstanceValid(id, oldInstance), TEE_INVALID_INSTANCE());

    //     if (newInstance != oldInstance && newInstance != address(0)) {
    //         _replaceInstance(id, oldInstance, newInstance);
    //     }
    // }

    // /// @inheritdoc IVerifier
    // function verifyBatchProof(
    //     ContextV2[] calldata _ctxs,
    //     TaikoData.TierProof calldata _proof
    // )
    //     external
    //     onlyFromNamedEither(LibStrings.B_TAIKO, LibStrings.B_TIER_TEE_ANY)
    // {
    //     // Size is: 109 bytes
    //     // 4 bytes + 20 bytes + 20 bytes + 65 bytes (signature) = 109
    //     require(_proof.data.length == 109, SGX_INVALID_PROOF());

    //     uint32 id = uint32(bytes4(_proof.data[:4]));
    //     address oldInstance = address(bytes20(_proof.data[4:24]));
    //     address newInstance = address(bytes20(_proof.data[24:44]));
    //     bytes memory signature = _proof.data[44:];

    //     // Collect public inputs
    //     bytes32[] memory publicInputs = new bytes32[](_ctxs.length + 2);
    //     // First public input is the current instance public key
    //     publicInputs[0] = bytes32(uint256(uint160(oldInstance)));
    //     publicInputs[1] = bytes32(uint256(uint160(newInstance)));
    //     // All other inputs are the block program public inputs (a single 32 byte value)
    //     for (uint256 i; i < _ctxs.length; ++i) {
    //         // TODO: For now this assumes the new instance public key to remain the same
    //         publicInputs[i + 2] = LibPublicInput.hashPublicInputs(
    //             _ctxs[i].tran,
    //             address(this),
    //             newInstance,
    //             _ctxs[i].prover,
    //             _ctxs[i].metaHash,
    //             taikoChainId()
    //         );
    //     }

    //     bytes32 signatureHash = keccak256(abi.encodePacked(publicInputs));
    //     // Verify the blocks
    //     require(oldInstance == ECDSA.recover(signatureHash, signature), SGX_INVALID_PROOF());

    //     require(_isInstanceValid(id, oldInstance), TEE_INVALID_INSTANCE());

    //     if (newInstance != oldInstance && newInstance != address(0)) {
    //         _replaceInstance(id, oldInstance, newInstance);
    //     }
    // }

    // function taikoChainId() internal view virtual returns (uint64) {
    //     return ITaikoL1(resolve(LibStrings.B_TAIKO, false)).getConfig().chainId;
    // }

    // function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {
    //     // Replacing an instance means, it went through a cooldown (if added by on-chain RA) so no
    //     // need to have a cooldown
    //     instances[id] = TeeInstance(newInstance, uint64(block.timestamp));
    //     emit InstanceAdded(id, newInstance, oldInstance, block.timestamp);
    // }

    // function _isInstanceValid(uint256 id, address instance) private view returns (bool) {
    //     require(instance != address(0), TEE_INVALID_INSTANCE());
    //     require(instance == instances[id].addr, TEE_INVALID_INSTANCE());
    //     return instances[id].validSince <= block.timestamp
    //         && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY;
    // }
}

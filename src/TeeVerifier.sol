// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {AutomataDcapAttestation} from "automata-dcap-attestation/contracts/AutomataDcapAttestation.sol";
import {V3QuoteVerifier} from "automata-dcap-attestation/contracts/verifiers/V3QuoteVerifier.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
// import "./LibPublicInput.sol";

/// @title TeeVerifier
/// @notice Registers public keys to verify state transition signatures created by the off-chain TEE
/// prover. Uses Automata's on-chain DCAP Quote Verifier to ensure keys are generated in a secure
/// enclave. Inspired by the MIT-licensed Taiko implementation. Supports both Intel SGX and TDX.
/// @dev To learn more, see:
/// - Original idea:
///   https://ethresear.ch/t/2fa-zk-rollups-using-sgx/14462
/// - Automata onchain verifier:
///   https://github.com/automata-network/automata-dcap-attestation
/// - Taiko SGX verifier:
///   https://github.com/taikoxyz/taiko-mono/blob/de92b28c03b747845a8a1aa26991307d1ed47fd0/packages/protocol/contracts/layer1/verifiers/SgxVerifier.sol
/// @custom:security-contact security@matterlabs.dev
contract TeeVerifier is Ownable {
    /// @dev Validity of key pairs (instances) attested and registered in this contract.
    struct TeeInstance {
        uint64 validSince;
    }

    /// @notice The maximum expiry time for the key pair (TeeInstance). After this time, a new key
    /// pair must be regenerated off-chain, re-attested, and re-registered on-chain. The actual
    /// validity can be shorter if the attestation determines so (e.g., due to certificate
    /// expiration) or if the TEE prover decides to generate a new key pair earlier.
    uint64 public constant INSTANCE_EXPIRY = 60 days;

    /// @dev Collection of all public keys registered on-chain. The off-chain TEE prover uses the
    /// corresponding private keys to sign state transitions in the secure enclave. Each public key
    /// can be used to sign multiple transitions without rotating the keys for each verification
    /// (unlike in Taiko's implementation). Each key pair is generated by the off-chain TEE prover
    /// in a secure enclave and must be attested on-chain by verifying a remote attestation quote.
    /// Public keys are represented as Ethereum addresses to use the `ecrecover` precompile for
    /// signer address retrieval.
    mapping(address => TeeInstance) public instances;

    AutomataDcapAttestation attest;

    uint256[48] private __gap;

    constructor(address _attest) Ownable(msg.sender) {
        require(_attest != address(0), TEE_RA_NOT_SUPPORTED());
        attest = AutomataDcapAttestation(_attest);
    }

    /// @notice Emitted when a new instance is added or replaced.
    /// @param new_instance The address of the new instance.
    /// @param old_instance The address of the instance that was replaced. If it is the first instance,
    /// this value is the zero address.
    /// @param validSince The time since the instance is valid.
    /// @param validUntil The time until the instance is valid.
    event InstanceAdded(
        address indexed new_instance,
        address indexed old_instance,
        uint256 validSince,
        uint256 validUntil
    );

    /// @notice Emitted when an TEE instance is deleted.
    /// @param addr The address of the TEE instance.
    event InstanceDeleted(address indexed addr);

    error TEE_ALREADY_ATTESTED();
    error TEE_INVALID_INSTANCE();
    error TEE_RA_NOT_SUPPORTED();
    error TEE_INVALID_ATTESTATION(string errorMsg);
    // error TEE_INVALID_PROOF();

    /// @notice Deletes TEE instances from the registry.
    /// @param _addresses The array of TEE instance addresses to be deleted.
    function deleteInstances(address[] calldata _addresses) external onlyOwner {
        for (uint256 i; i < _addresses.length; ++i) {
            this.deleteInstance(_addresses[i]);
        }
    }

    /// @notice Deletes a single TEE instance from the registry.
    /// @param addr The address of the SGX instance to be deleted.
    function deleteInstance(address addr) external onlyOwner {
        require(addr != address(0), TEE_INVALID_INSTANCE());
        emit InstanceDeleted(addr);
        delete instances[addr];
    }

    function registerInstance(bytes calldata _quote) external {
        this.registerInstance(_quote, 0);
    }

    /// @notice Adds an TEE instance after verifying the attestation.
    /// @param _quote The attestation quote.
    /// @param _validity_delay_in_seconds Delay in seconds before an instance becomes valid.
    function registerInstance(
        bytes calldata _quote,
        uint64 _validity_delay_in_seconds
    ) external {
        (bool verified, bytes memory errMsg) = attest.verifyAndAttestOnChain(
            _quote
        );

        require(verified, TEE_INVALID_ATTESTATION(string(errMsg)));
        address addr = address(bytes20(_quote[28:48]));
        uint64 valid_since = uint64(block.timestamp) +
            _validity_delay_in_seconds;
        _addInstance(addr, valid_since);
    }

    function _addInstance(address _addr, uint64 _validSince) private {
        require(_addr != address(0), TEE_INVALID_INSTANCE());
        require(instances[_addr].validSince == 0, TEE_ALREADY_ATTESTED());

        instances[_addr] = TeeInstance(_validSince);

        emit InstanceAdded(
            _addr,
            address(0),
            _validSince,
            _validSince + INSTANCE_EXPIRY
        );
    }

    // /// @inheritdoc IVerifier
    // function verifyProof(
    //     Context calldata _ctx,
    //     TaikoData.Transition calldata _tran,
    //     TaikoData.TierProof calldata _proof
    // )
    //     external
    //     onlyFromNamedEither(LibStrings.B_TAIKO, LibStrings.B_TIER_TEE_ANY)
    // {
    //     // Do not run proof verification to contest an existing proof
    //     if (_ctx.isContesting) return;

    //     // Size is: 89 bytes
    //     // 4 bytes + 20 bytes + 65 bytes (signature) = 89
    //     require(_proof.data.length == 89, SGX_INVALID_PROOF());

    //     uint32 id = uint32(bytes4(_proof.data[:4]));
    //     address newInstance = address(bytes20(_proof.data[4:24]));

    //     address oldInstance = ECDSA.recover(
    //         LibPublicInput.hashPublicInputs(
    //             _tran, address(this), newInstance, _ctx.prover, _ctx.metaHash, taikoChainId()
    //         ),
    //         _proof.data[24:]
    //     );

    //     require(_isInstanceValid(id, oldInstance), TEE_INVALID_INSTANCE());

    //     if (newInstance != oldInstance && newInstance != address(0)) {
    //         _replaceInstance(id, oldInstance, newInstance);
    //     }
    // }

    // /// @inheritdoc IVerifier
    // function verifyBatchProof(
    //     ContextV2[] calldata _ctxs,
    //     TaikoData.TierProof calldata _proof
    // )
    //     external
    //     onlyFromNamedEither(LibStrings.B_TAIKO, LibStrings.B_TIER_TEE_ANY)
    // {
    //     // Size is: 109 bytes
    //     // 4 bytes + 20 bytes + 20 bytes + 65 bytes (signature) = 109
    //     require(_proof.data.length == 109, SGX_INVALID_PROOF());

    //     uint32 id = uint32(bytes4(_proof.data[:4]));
    //     address oldInstance = address(bytes20(_proof.data[4:24]));
    //     address newInstance = address(bytes20(_proof.data[24:44]));
    //     bytes memory signature = _proof.data[44:];

    //     // Collect public inputs
    //     bytes32[] memory publicInputs = new bytes32[](_ctxs.length + 2);
    //     // First public input is the current instance public key
    //     publicInputs[0] = bytes32(uint256(uint160(oldInstance)));
    //     publicInputs[1] = bytes32(uint256(uint160(newInstance)));
    //     // All other inputs are the block program public inputs (a single 32 byte value)
    //     for (uint256 i; i < _ctxs.length; ++i) {
    //         // TODO: For now this assumes the new instance public key to remain the same
    //         publicInputs[i + 2] = LibPublicInput.hashPublicInputs(
    //             _ctxs[i].tran,
    //             address(this),
    //             newInstance,
    //             _ctxs[i].prover,
    //             _ctxs[i].metaHash,
    //             taikoChainId()
    //         );
    //     }

    //     bytes32 signatureHash = keccak256(abi.encodePacked(publicInputs));
    //     // Verify the blocks
    //     require(oldInstance == ECDSA.recover(signatureHash, signature), SGX_INVALID_PROOF());

    //     require(_isInstanceValid(id, oldInstance), TEE_INVALID_INSTANCE());

    //     if (newInstance != oldInstance && newInstance != address(0)) {
    //         _replaceInstance(id, oldInstance, newInstance);
    //     }
    // }

    // function taikoChainId() internal view virtual returns (uint64) {
    //     return ITaikoL1(resolve(LibStrings.B_TAIKO, false)).getConfig().chainId;
    // }

    // function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {
    //     // Replacing an instance means, it went through a cooldown (if added by on-chain RA) so no
    //     // need to have a cooldown
    //     instances[id] = TeeInstance(newInstance, uint64(block.timestamp));
    //     emit InstanceAdded(id, newInstance, oldInstance, block.timestamp);
    // }

    // function _isInstanceValid(uint256 id, address instance) private view returns (bool) {
    //     require(instance != address(0), TEE_INVALID_INSTANCE());
    //     require(instance == instances[id].addr, TEE_INVALID_INSTANCE());
    //     return instances[id].validSince <= block.timestamp
    //         && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY;
    // }
}
